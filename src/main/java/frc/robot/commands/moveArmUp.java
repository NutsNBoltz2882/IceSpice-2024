// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import java.util.function.DoubleSupplier;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.Intake;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
//ignore these these "AUTO GENERATE " stuff is from the tool RobotBuilder

/**
 *
 */
public class moveArmUp extends Command {
    private final Intake m_intake;
    private double targetPosition;
    private static final double kToleranceCounts = 10;

    public moveArmUp(Intake subsystem) {
        m_intake = subsystem;
        addRequirements(m_intake);
    }

    @Override
    public void initialize() {
        // Get the current position in degrees
        double currentPos = m_intake.getIntakeEncoderPosition();

        // Initialize the targetPosition variable if the current position isn't 170
        if( currentPos != 170){
            //sets the target position so it knows how far the move the arm
            targetPosition = 170;
        }
    }

    @Override
    public void execute() {
        // Get the current position in degrees
        double currentPos = m_intake.getIntakeEncoderPosition();

        // Example: Adjust motor speed based on the error between current position and target position
        double error = targetPosition - currentPos;
        double kP = 1; // Adjust this proportional constant as needed

        // Example: If the intake is below the target position, move the arm forward
        if (Math.abs(error) > 1.0) { // Check if the error is greater than 1 degree to avoid constant movement
            // Calculate motor speed based on the error
            double motorSpeed = kP * error;

            // Set the motor speed to move the arm
            m_intake.moveArm(motorSpeed);

            // Display the current position on SmartDashboard
            SmartDashboard.putNumber("Intake Current Position (Degrees)", currentPos);
        } else {
            // Stop the motor if the intake is at or above the target position
            m_intake.stopArm();
            m_intake.armStatus(true);

            // Display the current position on SmartDashboard
            SmartDashboard.putNumber("Intake Current Position (Degrees)", currentPos);
        }
    }

    @Override
    public boolean isFinished() {
        return Math.abs(targetPosition - m_intake.getIntakeEncoderPosition()) < kToleranceCounts;
    }

    @Override
    public void end(boolean interrupted) {
        //tells oif the command ended due to an interruption
        SmartDashboard.putBoolean("Arm Up command was interrupted", interrupted);
        //stops the arm from moving when the command ends
        m_intake.stopArm();
    }

    @Override
    public boolean runsWhenDisabled() {
        return false;
    }
}